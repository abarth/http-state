<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>

<!--
     ASCII to XML transformation by Invisible Worlds, Inc.
     http://invisible.net/
     Last transformation: 03-Feb-1999, 02:03:51

     Cannonical version of this document is at:
     http://info.internet.isi.edu/in-notes/rfc/files/rfc2109.txt

     Implementors should verify all content with
     cannonical version.  Failure to do so may result in
     protocol failures.
-->

<rfc number="2109"
     category="std">
<front>
<title>HTTP State Management Mechanism</title>
<author initials="D.M." surname="Kristol" fullname="David M. Kristol">
<organization>Bell Laboratories, Lucent Technologies</organization>
<address>
<postal>
<street>600 Mountain Ave.  Room 2A-227</street>
<street>Murray Hill</street>
<street>NJ  07974</street>
</postal>
<phone>(908) 582-2250</phone>
<facsimile>(908) 582-5809</facsimile>
<email>dmk@bell-labs.com</email>
</address>
</author>
<author initials="L." surname="Montulli" fullname="Lou Montulli">
<organization>Netscape Communications Corp.</organization>
<address>
<postal>
<street>501 E. Middlefield Rd.</street>
<street>Mountain View</street>
<street>CA  94043</street>
</postal>
<phone>(415) 528-2600</phone>
<email>montulli@netscape.com</email>
</address>
</author>
<date month="February" year="1997"/>
<keyword>cookie</keyword>
<keyword>hypertext transfer protocol</keyword>
</front>
<middle>
<!-- RFC original section: (1.) -->
<section title="ABSTRACT">
<t>
   This document specifies a way to create a stateful session with HTTP
   requests and responses.  It describes two new headers, Cookie and
   Set-Cookie, which carry state information between participating
   origin servers and user agents.  The method described here differs
   from Netscape&apos;s Cookie proposal, but it can interoperate with
   HTTP/1.0 user agents that use Netscape&apos;s method.  (See the HISTORICAL
   section.)
</t>
</section>
<!-- RFC original section: (2.) -->
<section title="TERMINOLOGY">
<t>
   The terms user agent, client, server, proxy, and origin server have
   the same meaning as in the HTTP/1.0 specification.
</t>
<t>
   Fully-qualified host name (FQHN) means either the fully-qualified
   domain name (FQDN) of a host (i.e., a completely specified domain
   name ending in a top-level domain such as .com or .uk), or the
   numeric Internet Protocol (IP) address of a host.  The fully
   qualified domain name is preferred; use of numeric IP addresses is
   strongly discouraged.
</t>
<t>
   The terms request-host and request-URI refer to the values the client
   would send to the server as, respectively, the host (but not port)
   and abs_path portions of the absoluteURI (http_URL) of the HTTP
   request line.  Note that request-host must be a FQHN.
   Hosts names can be specified either as an IP address or a FQHN
   string.  Sometimes we compare one host name with another.  Host A&apos;s
   name domain-matches host B&apos;s if
<list>
<t>
   * both host names are IP addresses and their host name strings match
     exactly; or
</t>
<t>
   * both host names are FQDN strings and their host name strings match
     exactly; or
</t>
<t>
   * A is a FQDN string and has the form NB, where N is a non-empty name
     string, B has the form .B&apos;, and B&apos; is a FQDN string.  (So, x.y.com
     domain-matches .y.com but not y.com.)
</t></list>
</t>
<t>
   Note that domain-match is not a commutative operation: a.b.c.com
   domain-matches .c.com, but not the reverse.
</t>
<t>
   Because it was used in Netscape&apos;s original implementation of state
   management, we will use the term cookie to refer to the state
   information that passes between an origin server and user agent, and
   that gets stored by the user agent.
</t>
</section>
<!-- RFC original section: (3.) -->
<section title="STATE AND SESSIONS">
<t>
   This document describes a way to create stateful sessions with HTTP
   requests and responses.  Currently, HTTP servers respond to each
   client request without relating that request to previous or
   subsequent requests; the technique allows clients and servers that
   wish to exchange state information to place HTTP requests and
   responses within a larger context, which we term a &quot;session&quot;.  This
   context might be used to create, for example, a &quot;shopping cart&quot;, in
   which user selections can be aggregated before purchase, or a
   magazine browsing system, in which a user&apos;s previous reading affects
   which offerings are presented.
</t>
<t>
   There are, of course, many different potential contexts and thus many
   different potential types of session.  The designers&apos; paradigm for
   sessions created by the exchange of cookies has these key attributes:
<list>
<t>
      1.  Each session has a beginning and an end.
</t>
<t>
      2.  Each session is relatively short-lived.
</t>
<t>
      3.  Either the user agent or the origin server may terminate a
          session.
</t>
<t>
      4.  The session is implicit in the exchange of state information.
</t></list>
</t>
</section>
<!-- RFC original section: (4.) -->
<section title="OUTLINE">
<t>
   We outline here a way for an origin server to send state information
   to the user agent, and for the user agent to return the state
   information to the origin server.  The goal is to have a minimal
   impact on HTTP and user agents.  Only origin servers that need to
   maintain sessions would suffer any significant impact, and that
   impact can largely be confined to Common Gateway Interface (CGI)
   programs, unless the server provides more sophisticated state
   management support.  (See Implementation Considerations, below.)
</t>
<!-- RFC original section: (4.1) -->
<section title="Syntax:  General">
<t>
   The two state management headers, Set-Cookie and Cookie, have common
   syntactic properties involving attribute-value pairs.  The following
   grammar uses the notation, and tokens DIGIT (decimal digits) and
   token (informally, a sequence of non-special, non-white space
   characters) from the HTTP/1.1 specification [RFC 2068] to describe
   their syntax.
</t>
<figure><artwork>
   av-pairs        =       av-pair *(&quot;;&quot; av-pair)
   av-pair         =       attr [&quot;=&quot; value]        ; optional value
   attr            =       token
   value           =       word
   word            =       token | quoted-string
</artwork></figure>
<t>
   Attributes (names) (attr) are case-insensitive.  White space is
   permitted between tokens.  Note that while the above syntax
   description shows value as optional, most attrs require them.
</t>
<t>
   NOTE: The syntax above allows whitespace between the attribute and
   the = sign.
</t>
</section>
<!-- RFC original section: (4.2) -->
<section title="Origin Server Role">
<t>
</t>
<!-- RFC original section: (4.2.1) -->
<section title="General">
<t>
   The origin server initiates a session, if it so desires.  (Note that
   &quot;session&quot; here does not refer to a persistent network connection but
   to a logical session created from HTTP requests and responses.  The
   presence or absence of a persistent connection should have no effect
   on the use of cookie-derived sessions).  To initiate a session, the
   origin server returns an extra response header to the client, Set-
   Cookie.  (The details follow later.)
</t>
<t>
   A user agent returns a Cookie request header (see below) to the
   origin server if it chooses to continue a session.  The origin server
   may ignore it or use it to determine the current state of the
   session.  It may send back to the client a Set-Cookie response header
   with the same or different information, or it may send no Set-Cookie
   header at all.  The origin server effectively ends a session by
   sending the client a Set-Cookie header with Max-Age=0.
</t>
<t>
   Servers may return a Set-Cookie response headers with any response.
   User agents should send Cookie request headers, subject to other
   rules detailed below, with every request.
</t>
<t>
   An origin server may include multiple Set-Cookie headers in a
   response.  Note that an intervening gateway could fold multiple such
   headers into a single header.
</t>
</section>
<!-- RFC original section: (4.2.2) -->
<section title="Set-Cookie Syntax">
<t>
   The syntax for the Set-Cookie response header is
</t>
<figure><artwork>
   set-cookie      =       &quot;Set-Cookie:&quot; cookies
   cookies         =       1#cookie
   cookie          =       NAME &quot;=&quot; VALUE *(&quot;;&quot; cookie-av)
   NAME            =       attr
   VALUE           =       value
   cookie-av       =       &quot;Comment&quot; &quot;=&quot; value
                   |       &quot;Domain&quot; &quot;=&quot; value
                   |       &quot;Max-Age&quot; &quot;=&quot; value
                   |       &quot;Path&quot; &quot;=&quot; value
                   |       &quot;Secure&quot;
                   |       &quot;Version&quot; &quot;=&quot; 1*DIGIT
</artwork></figure>
<t>
   Informally, the Set-Cookie response header comprises the token Set-
   Cookie:, followed by a comma-separated list of one or more cookies.
   Each cookie begins with a NAME=VALUE pair, followed by zero or more
   semi-colon-separated attribute-value pairs.  The syntax for
   attribute-value pairs was shown earlier.  The specific attributes and
   the semantics of their values follows.  The NAME=VALUE attribute-
   value pair must come first in each cookie.  The others, if present,
   can occur in any order.  If an attribute appears more than once in a
   cookie, the behavior is undefined.
<list>
<t>
   NAME=VALUE
<list>
<t>
      Required.  The name of the state information (&quot;cookie&quot;) is NAME,
      and its value is VALUE.  NAMEs that begin with $ are reserved for
      other uses and must not be used by applications.
      The VALUE is opaque to the user agent and may be anything the
      origin server chooses to send, possibly in a server-selected
      printable ASCII encoding.  &quot;Opaque&quot; implies that the content is of
      interest and relevance only to the origin server.  The content
      may, in fact, be readable by anyone that examines the Set-Cookie
      header.
</t></list>
</t>
<t>
   Comment=comment
<list>
<t>
      Optional.  Because cookies can contain private information about a
      user, the Cookie attribute allows an origin server to document its
      intended use of a cookie.  The user can inspect the information to
      decide whether to initiate or continue a session with this cookie.
</t></list>
</t>
<t>
   Domain=domain
<list>
<t>
      Optional.  The Domain attribute specifies the domain for which the
      cookie is valid.  An explicitly specified domain must always start
      with a dot.
</t></list>
</t>
<t>
   Max-Age=delta-seconds
<list>
<t>
      Optional.  The Max-Age attribute defines the lifetime of the
      cookie, in seconds.  The delta-seconds value is a decimal non-
      negative integer.  After delta-seconds seconds elapse, the client
      should discard the cookie.  A value of zero means the cookie
      should be discarded immediately.
</t></list>
</t>
<t>
   Path=path
<list>
<t>
      Optional.  The Path attribute specifies the subset of URLs to
      which this cookie applies.
</t></list>
</t>
<t>
   Secure
<list>
<t>
      Optional.  The Secure attribute (with no value) directs the user
      agent to use only (unspecified) secure means to contact the origin
      server whenever it sends back this cookie.
</t>
<t>
      The user agent (possibly under the user&apos;s control) may determine
      what level of security it considers appropriate for &quot;secure&quot;
      cookies.  The Secure attribute should be considered security
      advice from the server to the user agent, indicating that it is in
      the session&apos;s interest to protect the cookie contents.
</t></list>
</t>
<t>
   Version=version
<list>
<t>
      Required.  The Version attribute, a decimal integer, identifies to
      which version of the state management specification the cookie
      conforms.  For this specification, Version=1 applies.
</t></list>
</t></list>
</t>
</section>
<!-- RFC original section: (4.2.3) -->
<section title="Controlling Caching">
<t>
   An origin server must be cognizant of the effect of possible caching
   of both the returned resource and the Set-Cookie header.  Caching
   &quot;public&quot; documents is desirable.  For example, if the origin server
   wants to use a public document such as a &quot;front door&quot; page as a
   sentinel to indicate the beginning of a session for which a Set-
   Cookie response header must be generated, the page should be stored
   in caches &quot;pre-expired&quot; so that the origin server will see further
   requests.  &quot;Private documents&quot;, for example those that contain
   information strictly private to a session, should not be cached in
   shared caches.
</t>
<t>
   If the cookie is intended for use by a single user, the Set-cookie
   header should not be cached.  A Set-cookie header that is intended to
   be shared by multiple users may be cached.
</t>
<t>
   The origin server should send the following additional HTTP/1.1
   response headers, depending on circumstances:
<list>
<t>
   * To suppress caching of the Set-Cookie header: Cache-control: no-
     cache=&quot;set-cookie&quot;.
</t></list>
</t>
<t>
   and one of the following:
<list>
<t>
   * To suppress caching of a private document in shared caches: Cache-
     control: private.
</t>
<t>
   * To allow caching of a document and require that it be validated
     before returning it to the client: Cache-control: must-revalidate.
</t>
<t>
   * To allow caching of a document, but to require that proxy caches
     (not user agent caches) validate it before returning it to the
     client: Cache-control: proxy-revalidate.
</t>
<t>
   * To allow caching of a document and request that it be validated
     before returning it to the client (by &quot;pre-expiring&quot; it):
     Cache-control: max-age=0.  Not all caches will revalidate the
     document in every case.
</t></list>
</t>
<t>
   HTTP/1.1 servers must send Expires: old-date (where old-date is a
   date long in the past) on responses containing Set-Cookie response
   headers unless they know for certain (by out of band means) that
   there are no downsteam HTTP/1.0 proxies.  HTTP/1.1 servers may send
   other Cache-Control directives that permit caching by HTTP/1.1
   proxies in addition to the Expires: old-date directive; the Cache-
   Control directive will override the Expires: old-date for HTTP/1.1
   proxies.
</t>
</section>
</section>
<!-- RFC original section: (4.3) -->
<section title="User Agent Role">
<t>
</t>
<!-- RFC original section: (4.3.1) -->
<section title="Interpreting Set-Cookie">
<t>
   The user agent keeps separate track of state information that arrives
   via Set-Cookie response headers from each origin server (as
   distinguished by name or IP address and port).  The user agent
   applies these defaults for optional attributes that are missing:
<list>
<t>
   VersionDefaults to &quot;old cookie&quot; behavior as originally specified by
          Netscape.  See the HISTORICAL section.
</t>
<t>
   Domain Defaults to the request-host.  (Note that there is no dot at
          the beginning of request-host.)
</t>
<t>
   Max-AgeThe default behavior is to discard the cookie when the user
          agent exits.
</t>
<t>
   Path   Defaults to the path of the request URL that generated the
          Set-Cookie response, up to, but not including, the
          right-most /.
</t>
<t>
   Secure If absent, the user agent may send the cookie over an
          insecure channel.
</t></list>
</t>
</section>
<!-- RFC original section: (4.3.2) -->
<section title="Rejecting Cookies">
<t>
   To prevent possible security or privacy violations, a user agent
   rejects a cookie (shall not store its information) if any of the
   following is true:
<list>
<t>
   * The value for the Path attribute is not a prefix of the request-
     URI.
</t>
<t>
   * The value for the Domain attribute contains no embedded dots or
     does not start with a dot.
</t>
<t>
   * The value for the request-host does not domain-match the Domain
     attribute.
</t>
<t>
   * The request-host is a FQDN (not IP address) and has the form HD,
     where D is the value of the Domain attribute, and H is a string
     that contains one or more dots.
</t></list>
</t>
<t>
   Examples:
<list>
<t>
   * A Set-Cookie from request-host y.x.foo.com for Domain=.foo.com
     would be rejected, because H is y.x and contains a dot.
   * A Set-Cookie from request-host x.foo.com for Domain=.foo.com would
     be accepted.
</t>
<t>
   * A Set-Cookie with Domain=.com or Domain=.com., will always be
     rejected, because there is no embedded dot.
</t>
<t>
   * A Set-Cookie with Domain=ajax.com will be rejected because the
     value for Domain does not begin with a dot.
</t></list>
</t>
</section>
<!-- RFC original section: (4.3.3) -->
<section title="Cookie Management">
<t>
   If a user agent receives a Set-Cookie response header whose NAME is
   the same as a pre-existing cookie, and whose Domain and Path
   attribute values exactly (string) match those of a pre-existing
   cookie, the new cookie supersedes the old.  However, if the Set-
   Cookie has a value for Max-Age of zero, the (old and new) cookie is
   discarded.  Otherwise cookies accumulate until they expire (resources
   permitting), at which time they are discarded.
</t>
<t>
   Because user agents have finite space in which to store cookies, they
   may also discard older cookies to make space for newer ones, using,
   for example, a least-recently-used algorithm, along with constraints
   on the maximum number of cookies that each origin server may set.
</t>
<t>
   If a Set-Cookie response header includes a Comment attribute, the
   user agent should store that information in a human-readable form
   with the cookie and should display the comment text as part of a
   cookie inspection user interface.
</t>
<t>
   User agents should allow the user to control cookie destruction.  An
   infrequently-used cookie may function as a &quot;preferences file&quot; for
   network applications, and a user may wish to keep it even if it is
   the least-recently-used cookie.  One possible implementation would be
   an interface that allows the permanent storage of a cookie through a
   checkbox (or, conversely, its immediate destruction).
</t>
<t>
   Privacy considerations dictate that the user have considerable
   control over cookie management.  The PRIVACY section contains more
   information.
</t>
</section>
<!-- RFC original section: (4.3.4) -->
<section title="Sending Cookies to the Origin Server">
<t>
   When it sends a request to an origin server, the user agent sends a
   Cookie request header to the origin server if it has cookies that are
   applicable to the request, based on
<list>
<t>
   * the request-host;
</t>
<t>
   * the request-URI;
</t>
<t>
   * the cookie&apos;s age.
</t></list>
</t>
<t>
   The syntax for the header is:
</t>
<figure><artwork>
   cookie          =       &quot;Cookie:&quot; cookie-version
                           1*((&quot;;&quot; | &quot;,&quot;) cookie-value)
   cookie-value    =       NAME &quot;=&quot; VALUE [&quot;;&quot; path] [&quot;;&quot; domain]
   cookie-version  =       &quot;$Version&quot; &quot;=&quot; value
   NAME            =       attr
   VALUE           =       value
   path            =       &quot;$Path&quot; &quot;=&quot; value
   domain          =       &quot;$Domain&quot; &quot;=&quot; value
</artwork></figure>
<t>
   The value of the cookie-version attribute must be the value from the
   Version attribute, if any, of the corresponding Set-Cookie response
   header.  Otherwise the value for cookie-version is 0.  The value for
   the path attribute must be the value from the Path attribute, if any,
   of the corresponding Set-Cookie response header.  Otherwise the
   attribute should be omitted from the Cookie request header.  The
   value for the domain attribute must be the value from the Domain
   attribute, if any, of the corresponding Set-Cookie response header.
   Otherwise the attribute should be omitted from the Cookie request
   header.
</t>
<t>
   Note that there is no Comment attribute in the Cookie request header
   corresponding to the one in the Set-Cookie response header.  The user
   agent does not return the comment information to the origin server.
</t>
<t>
   The following rules apply to choosing applicable cookie-values from
   among all the cookies the user agent has.
<list>
<t>
   Domain Selection
<list>
<t>
        The origin server&apos;s fully-qualified host name must domain-match
        the Domain attribute of the cookie.
</t></list>
</t>
<t>
   Path Selection
<list>
<t>
        The Path attribute of the cookie must match a prefix of the
        request-URI.
</t></list>
</t>
<t>
   Max-Age Selection
<list>
<t>
        Cookies that have expired should have been discarded and thus
        are not forwarded to an origin server.
</t></list>
</t></list>
</t>
<t>
   If multiple cookies satisfy the criteria above, they are ordered in
   the Cookie header such that those with more specific Path attributes
   precede those with less specific.  Ordering with respect to other
   attributes (e.g., Domain) is unspecified.
</t>
<t>
   Note: For backward compatibility, the separator in the Cookie header
   is semi-colon (;) everywhere.  A server should also accept comma (,)
   as the separator between cookie-values for future compatibility.
</t>
</section>
<!-- RFC original section: (4.3.5) -->
<section title="Sending Cookies in Unverifiable Transactions">
<t>
   Users must have control over sessions in order to ensure privacy.
   (See PRIVACY section below.)  To simplify implementation and to
   prevent an additional layer of complexity where adequate safeguards
   exist, however, this document distinguishes between transactions that
   are verifiable and those that are unverifiable.  A transaction is
   verifiable if the user has the option to review the request-URI prior
   to its use in the transaction.  A transaction is unverifiable if the
   user does not have that option.  Unverifiable transactions typically
   arise when a user agent automatically requests inlined or embedded
   entities or when it resolves redirection (3xx) responses from an
   origin server.  Typically the origin transaction, the transaction
   that the user initiates, is verifiable, and that transaction may
   directly or indirectly induce the user agent to make unverifiable
   transactions.
</t>
<t>
   When it makes an unverifiable transaction, a user agent must enable a
   session only if a cookie with a domain attribute D was sent or
   received in its origin transaction, such that the host name in the
   Request-URI of the unverifiable transaction domain-matches D.
</t>
<t>
   This restriction prevents a malicious service author from using
   unverifiable transactions to induce a user agent to start or continue
   a session with a server in a different domain.  The starting or
   continuation of such sessions could be contrary to the privacy
   expectations of the user, and could also be a security problem.
</t>
<t>
   User agents may offer configurable options that allow the user agent,
   or any autonomous programs that the user agent executes, to ignore
   the above rule, so long as these override options default to &quot;off&quot;.
</t>
<t>
   Many current user agents already provide a review option that would
   render many links verifiable.  For instance, some user agents display
   the URL that would be referenced for a particular link when the mouse
   pointer is placed over that link.  The user can therefore determine
   whether to visit that site before causing the browser to do so.
   (Though not implemented on current user agents, a similar technique
   could be used for a button used to submit a form -- the user agent
   could display the action to be taken if the user were to select that
   button.) However, even this would not make all links verifiable; for
   example, links to automatically loaded images would not normally be
   subject to &quot;mouse pointer&quot; verification.
</t>
<t>
   Many user agents also provide the option for a user to view the HTML
   source of a document, or to save the source to an external file where
   it can be viewed by another application.  While such an option does
   provide a crude review mechanism, some users might not consider it
   acceptable for this purpose.
</t>
</section>
</section>
<!-- RFC original section: (4.4) -->
<section title="How an Origin Server Interprets the Cookie Header">
<t>
   A user agent returns much of the information in the Set-Cookie header
   to the origin server when the Path attribute matches that of a new
   request.  When it receives a Cookie header, the origin server should
   treat cookies with NAMEs whose prefix is $ specially, as an attribute
   for the adjacent cookie.  The value for such a NAME is to be
   interpreted as applying to the lexically (left-to-right) most recent
   cookie whose name does not have the $ prefix.  If there is no
   previous cookie, the value applies to the cookie mechanism as a
   whole.  For example, consider the cookie
</t>
<figure><artwork>
   Cookie: $Version=&quot;1&quot;; Customer=&quot;WILE_E_COYOTE&quot;;
           $Path=&quot;/acme&quot;
</artwork></figure>
<t>
   $Version applies to the cookie mechanism as a whole (and gives the
   version number for the cookie mechanism).  $Path is an attribute
   whose value (/acme) defines the Path attribute that was used when the
   Customer cookie was defined in a Set-Cookie response header.
</t>
</section>
<!-- RFC original section: (4.5) -->
<section title="Caching Proxy Role">
<t>
   One reason for separating state information from both a URL and
   document content is to facilitate the scaling that caching permits.
   To support cookies, a caching proxy must obey these rules already in
   the HTTP specification:
<list>
<t>
   * Honor requests from the cache, if possible, based on cache validity
     rules.
</t>
<t>
   * Pass along a Cookie request header in any request that the proxy
     must make of another server.
</t>
<t>
   * Return the response to the client.  Include any Set-Cookie response
     header.
   * Cache the received response subject to the control of the usual
     headers, such as Expires, Cache-control: no-cache, and Cache-
     control: private,
</t>
<t>
   * Cache the Set-Cookie subject to the control of the usual header,
     Cache-control: no-cache=&quot;set-cookie&quot;.  (The Set-Cookie header
     should usually not be cached.)
</t></list>
</t>
<t>
   Proxies must not introduce Set-Cookie (Cookie) headers of their own
   in proxy responses (requests).
</t>
</section>
</section>
<!-- RFC original section: (5.) -->
<section title="EXAMPLES">
<t>
</t>
<!-- RFC original section: (5.1) -->
<section title="Example 1">
<t>
   Most detail of request and response headers has been omitted.  Assume
   the user agent has no stored cookies.
</t>
<t>
     1.  User Agent -&gt; Server
</t>
<figure><artwork>
         POST /acme/login HTTP/1.1
         [form data]
</artwork></figure>
<t>
         User identifies self via a form.
</t>
<t>
     2.  Server -&gt; User Agent
</t>
<figure><artwork>
         HTTP/1.1 200 OK
         Set-Cookie: Customer=&quot;WILE_E_COYOTE&quot;; Version=&quot;1&quot;; Path=&quot;/acme&quot;
</artwork></figure>
<t>
         Cookie reflects user&apos;s identity.
</t>
<t>
     3.  User Agent -&gt; Server
</t>
<figure><artwork>
         POST /acme/pickitem HTTP/1.1
         Cookie: $Version=&quot;1&quot;; Customer=&quot;WILE_E_COYOTE&quot;; $Path=&quot;/acme&quot;
         [form data]
</artwork></figure>
<t>
         User selects an item for &quot;shopping basket.&quot;
</t>
<t>
     4.  Server -&gt; User Agent
</t>
<figure><artwork>
         HTTP/1.1 200 OK
         Set-Cookie: Part_Number=&quot;Rocket_Launcher_0001&quot;; Version=&quot;1&quot;;
                 Path=&quot;/acme&quot;
</artwork></figure>
<t>
         Shopping basket contains an item.
</t>
<t>
     5.  User Agent -&gt; Server
</t>
<figure><artwork>
         POST /acme/shipping HTTP/1.1
         Cookie: $Version=&quot;1&quot;;
                 Customer=&quot;WILE_E_COYOTE&quot;; $Path=&quot;/acme&quot;;
                 Part_Number=&quot;Rocket_Launcher_0001&quot;; $Path=&quot;/acme&quot;
         [form data]
</artwork></figure>
<t>
         User selects shipping method from form.
</t>
<t>
     6.  Server -&gt; User Agent
</t>
<figure><artwork>
         HTTP/1.1 200 OK
         Set-Cookie: Shipping=&quot;FedEx&quot;; Version=&quot;1&quot;; Path=&quot;/acme&quot;
</artwork></figure>
<t>
         New cookie reflects shipping method.
</t>
<t>
     7.  User Agent -&gt; Server
</t>
<figure><artwork>
         POST /acme/process HTTP/1.1
         Cookie: $Version=&quot;1&quot;;
                 Customer=&quot;WILE_E_COYOTE&quot;; $Path=&quot;/acme&quot;;
                 Part_Number=&quot;Rocket_Launcher_0001&quot;; $Path=&quot;/acme&quot;;
                 Shipping=&quot;FedEx&quot;; $Path=&quot;/acme&quot;
         [form data]
</artwork></figure>
<t>
         User chooses to process order.
</t>
<t>
     8.  Server -&gt; User Agent
</t>
<figure><artwork>
         HTTP/1.1 200 OK
</artwork></figure>
<t>
         Transaction is complete.
</t>
<t>
   The user agent makes a series of requests on the origin server, after
   each of which it receives a new cookie.  All the cookies have the
   same Path attribute and (default) domain.  Because the request URLs
   all have /acme as a prefix, and that matches the Path attribute, each
   request contains all the cookies received so far.
</t>
</section>
<!-- RFC original section: (5.2) -->
<section title="Example 2">
<t>
   This example illustrates the effect of the Path attribute.  All
   detail of request and response headers has been omitted.  Assume the
   user agent has no stored cookies.
</t>
<t>
   Imagine the user agent has received, in response to earlier requests,
   the response headers
</t>
<figure><artwork>
   Set-Cookie: Part_Number=&quot;Rocket_Launcher_0001&quot;; Version=&quot;1&quot;;
           Path=&quot;/acme&quot;
</artwork></figure>
<t>
   and
</t>
<figure><artwork>
   Set-Cookie: Part_Number=&quot;Riding_Rocket_0023&quot;; Version=&quot;1&quot;;
           Path=&quot;/acme/ammo&quot;
</artwork></figure>
<t>
   A subsequent request by the user agent to the (same) server for URLs
   of the form /acme/ammo/...  would include the following request
   header:
</t>
<figure><artwork>
   Cookie: $Version=&quot;1&quot;;
           Part_Number=&quot;Riding_Rocket_0023&quot;; $Path=&quot;/acme/ammo&quot;;
           Part_Number=&quot;Rocket_Launcher_0001&quot;; $Path=&quot;/acme&quot;
</artwork></figure>
<t>
   Note that the NAME=VALUE pair for the cookie with the more specific
   Path attribute, /acme/ammo, comes before the one with the less
   specific Path attribute, /acme.  Further note that the same cookie
   name appears more than once.
</t>
<t>
   A subsequent request by the user agent to the (same) server for a URL
   of the form /acme/parts/ would include the following request header:
</t>
<figure><artwork>
   Cookie: $Version=&quot;1&quot;; Part_Number=&quot;Rocket_Launcher_0001&quot;; $Path=&quot;/acme&quot;
</artwork></figure>
<t>
   Here, the second cookie&apos;s Path attribute /acme/ammo is not a prefix
   of the request URL, /acme/parts/, so the cookie does not get
   forwarded to the server.
</t>
</section>
</section>
<!-- RFC original section: (6.) -->
<section title="IMPLEMENTATION CONSIDERATIONS">
<t>
   Here we speculate on likely or desirable details for an origin server
   that implements state management.
</t>
<!-- RFC original section: (6.1) -->
<section title="Set-Cookie Content">
<t>
   An origin server&apos;s content should probably be divided into disjoint
   application areas, some of which require the use of state
   information.  The application areas can be distinguished by their
   request URLs.  The Set-Cookie header can incorporate information
   about the application areas by setting the Path attribute for each
   one.
</t>
<t>
   The session information can obviously be clear or encoded text that
   describes state.  However, if it grows too large, it can become
   unwieldy.  Therefore, an implementor might choose for the session
   information to be a key to a server-side resource.  Of course, using
   a database creates some problems that this state management
   specification was meant to avoid, namely:
<list>
<t>
     1.  keeping real state on the server side;
</t>
<t>
     2.  how and when to garbage-collect the database entry, in case the
         user agent terminates the session by, for example, exiting.
</t></list>
</t>
</section>
<!-- RFC original section: (6.2) -->
<section title="Stateless Pages">
<t>
   Caching benefits the scalability of WWW.  Therefore it is important
   to reduce the number of documents that have state embedded in them
   inherently.  For example, if a shopping-basket-style application
   always displays a user&apos;s current basket contents on each page, those
   pages cannot be cached, because each user&apos;s basket&apos;s contents would
   be different.  On the other hand, if each page contains just a link
   that allows the user to &quot;Look at My Shopping Basket&quot;, the page can be
   cached.
</t>
</section>
<!-- RFC original section: (6.3) -->
<section title="Implementation Limits">
<t>
   Practical user agent implementations have limits on the number and
   size of cookies that they can store.  In general, user agents&apos; cookie
   support should have no fixed limits.  They should strive to store as
   many frequently-used cookies as possible.  Furthermore, general-use
   user agents should provide each of the following minimum capabilities
   individually, although not necessarily simultaneously:
<list>
<t>
      * at least 300 cookies
</t>
<t>
      * at least 4096 bytes per cookie (as measured by the size of the
        characters that comprise the cookie non-terminal in the syntax
        description of the Set-Cookie header)
</t>
<t>
      * at least 20 cookies per unique host or domain name
</t></list>
</t>
<t>
   User agents created for specific purposes or for limited-capacity
   devices should provide at least 20 cookies of 4096 bytes, to ensure
   that the user can interact with a session-based origin server.
</t>
<t>
   The information in a Set-Cookie response header must be retained in
   its entirety.  If for some reason there is inadequate space to store
   the cookie, it must be discarded, not truncated.
</t>
<t>
   Applications should use as few and as small cookies as possible, and
   they should cope gracefully with the loss of a cookie.
</t>
<!-- RFC original section: (6.3.1) -->
<section title="Denial of Service Attacks">
<t>
   User agents may choose to set an upper bound on the number of cookies
   to be stored from a given host or domain name or on the size of the
   cookie information.  Otherwise a malicious server could attempt to
   flood a user agent with many cookies, or large cookies, on successive
   responses, which would force out cookies the user agent had received
   from other servers.  However, the minima specified above should still
   be supported.
</t>
</section>
</section>
</section>
<!-- RFC original section: (7.) -->
<section title="PRIVACY">
<t>
</t>
<!-- RFC original section: (7.1) -->
<section title="User Agent Control">
<t>
   An origin server could create a Set-Cookie header to track the path
   of a user through the server.  Users may object to this behavior as
   an intrusive accumulation of information, even if their identity is
   not evident.  (Identity might become evident if a user subsequently
   fills out a form that contains identifying information.)  This state
   management specification therefore requires that a user agent give
   the user control over such a possible intrusion, although the
   interface through which the user is given this control is left
   unspecified.  However, the control mechanisms provided shall at least
   allow the user
<list>
<t>
      * to completely disable the sending and saving of cookies.
</t>
<t>
      * to determine whether a stateful session is in progress.
</t>
<t>
      * to control the saving of a cookie on the basis of the cookie&apos;s
        Domain attribute.
</t></list>
</t>
<t>
   Such control could be provided by, for example, mechanisms
<list>
<t>
      * to notify the user when the user agent is about to send a cookie
        to the origin server, offering the option not to begin a session.
</t>
<t>
      * to display a visual indication that a stateful session is in
        progress.
</t>
<t>
      * to let the user decide which cookies, if any, should be saved
        when the user concludes a window or user agent session.
</t>
<t>
      * to let the user examine the contents of a cookie at any time.
</t></list>
</t>
<t>
   A user agent usually begins execution with no remembered state
   information.  It should be possible to configure a user agent never
   to send Cookie headers, in which case it can never sustain state with
   an origin server.  (The user agent would then behave like one that is
   unaware of how to handle Set-Cookie response headers.)
</t>
<t>
   When the user agent terminates execution, it should let the user
   discard all state information.  Alternatively, the user agent may ask
   the user whether state information should be retained; the default
   should be &quot;no&quot;.  If the user chooses to retain state information, it
   would be restored the next time the user agent runs.
</t>
<t>
   NOTE: User agents should probably be cautious about using files to
   store cookies long-term.  If a user runs more than one instance of
   the user agent, the cookies could be commingled or otherwise messed
   up.
</t>
</section>
<!-- RFC original section: (7.2) -->
<section title="Protocol Design">
<t>
   The restrictions on the value of the Domain attribute, and the rules
   concerning unverifiable transactions, are meant to reduce the ways
   that cookies can &quot;leak&quot; to the &quot;wrong&quot; site.  The intent is to
   restrict cookies to one, or a closely related set of hosts.
   Therefore a request-host is limited as to what values it can set for
   Domain.  We consider it acceptable for hosts host1.foo.com and
   host2.foo.com to share cookies, but not a.com and b.com.
</t>
<t>
   Similarly, a server can only set a Path for cookies that are related
   to the request-URI.
</t>
</section>
</section>
<!-- RFC original section: (8.) -->
<section title="SECURITY CONSIDERATIONS">
<t>
</t>
<!-- RFC original section: (8.1) -->
<section title="Clear Text">
<t>
   The information in the Set-Cookie and Cookie headers is unprotected.
   Two consequences are:
<list>
<t>
   1.  Any sensitive information that is conveyed in them is exposed
       to intruders.
</t>
<t>
   2.  A malicious intermediary could alter the headers as they travel
       in either direction, with unpredictable results.
</t></list>
</t>
<t>
   These facts imply that information of a personal and/or financial
   nature should only be sent over a secure channel.  For less sensitive
   information, or when the content of the header is a database key, an
   origin server should be vigilant to prevent a bad Cookie value from
   causing failures.
</t>
</section>
<!-- RFC original section: (8.2) -->
<section title="Cookie Spoofing">
<t>
   Proper application design can avoid spoofing attacks from related
   domains.  Consider:
<list>
<t>
     1.  User agent makes request to victim.cracker.edu, gets back
         cookie session_id=&quot;1234&quot; and sets the default domain
         victim.cracker.edu.
</t>
<t>
     2.  User agent makes request to spoof.cracker.edu, gets back
         cookie session-id=&quot;1111&quot;, with Domain=&quot;.cracker.edu&quot;.
</t>
<t>
     3.  User agent makes request to victim.cracker.edu again, and
         passes
</t></list>
</t>
<figure><artwork>
         Cookie: $Version=&quot;1&quot;;
                         session_id=&quot;1234&quot;;
                         session_id=&quot;1111&quot;; $Domain=&quot;.cracker.edu&quot;
</artwork></figure>
<t><list><t>
         The server at victim.cracker.edu should detect that the second
         cookie was not one it originated by noticing that the Domain
         attribute is not for itself and ignore it.
</t></list>
</t>
</section>
<!-- RFC original section: (8.3) -->
<section title="Unexpected Cookie Sharing">
<t>
   A user agent should make every attempt to prevent the sharing of
   session information between hosts that are in different domains.
   Embedded or inlined objects may cause particularly severe privacy
   problems if they can be used to share cookies between disparate
   hosts.  For example, a malicious server could embed cookie
   information for host a.com in a URI for a CGI on host b.com.  User
   agent implementors are strongly encouraged to prevent this sort of
   exchange whenever possible.
</t>
</section>
</section>
<!-- RFC original section: (9.) -->
<section title="OTHER, SIMILAR, PROPOSALS">
<t>
   Three other proposals have been made to accomplish similar goals.
   This specification is an amalgam of Kristol&apos;s State-Info proposal and
   Netscape&apos;s Cookie proposal.
</t>
<t>
   Brian Behlendorf proposed a Session-ID header that would be user-
   agent-initiated and could be used by an origin server to track
   &quot;clicktrails&quot;.  It would not carry any origin-server-defined state,
   however.  Phillip Hallam-Baker has proposed another client-defined
   session ID mechanism for similar purposes.
</t>
<t>
   While both session IDs and cookies can provide a way to sustain
   stateful sessions, their intended purpose is different, and,
   consequently, the privacy requirements for them are different.  A
   user initiates session IDs to allow servers to track progress through
   them, or to distinguish multiple users on a shared machine.  Cookies
   are server-initiated, so the cookie mechanism described here gives
   users control over something that would otherwise take place without
   the users&apos; awareness.  Furthermore, cookies convey rich, server-
   selected information, whereas session IDs comprise user-selected,
   simple information.
</t>
</section>
<!-- RFC original section: (10.) -->
<section title="HISTORICAL">
<t>
</t>
<!-- RFC original section: (10.1) -->
<section title="Compatibility With Netscape&apos;s Implementation">
<t>
   HTTP/1.0 clients and servers may use Set-Cookie and Cookie headers
   that reflect Netscape&apos;s original cookie proposal.  These notes cover
   inter-operation between &quot;old&quot; and &quot;new&quot; cookies.
</t>
<!-- RFC original section: (10.1.1) -->
<section title="Extended Cookie Header">
<t>
   This proposal adds attribute-value pairs to the Cookie request header
   in a compatible way.  An &quot;old&quot; client that receives a &quot;new&quot; cookie
   will ignore attributes it does not understand; it returns what it
   does understand to the origin server.  A &quot;new&quot; client always sends
   cookies in the new form.
</t>
<t>
   An &quot;old&quot; server that receives a &quot;new&quot; cookie will see what it thinks
   are many cookies with names that begin with a $, and it will ignore
   them.  (The &quot;old&quot; server expects these cookies to be separated by
   semi-colon, not comma.)  A &quot;new&quot; server can detect cookies that have
   passed through an &quot;old&quot; client, because they lack a $Version
   attribute.
</t>
</section>
<!-- RFC original section: (10.1.2) -->
<section title="Expires and Max-Age">
<t>
   Netscape&apos;s original proposal defined an Expires header that took a
   date value in a fixed-length variant format in place of Max-Age:
</t>
<figure><artwork>
   Wdy, DD-Mon-YY HH:MM:SS GMT
</artwork></figure>
<t>
   Note that the Expires date format contains embedded spaces, and that
   &quot;old&quot; cookies did not have quotes around values.  Clients that
   implement to this specification should be aware of &quot;old&quot; cookies and
   Expires.
</t>
</section>
<!-- RFC original section: (10.1.3) -->
<section title="Punctuation">
<t>
   In Netscape&apos;s original proposal, the values in attribute-value pairs
   did not accept &quot;-quoted strings.  Origin servers should be cautious
   about sending values that require quotes unless they know the
   receiving user agent understands them (i.e., &quot;new&quot; cookies).  A
   (&quot;new&quot;) user agent should only use quotes around values in Cookie
   headers when the cookie&apos;s version(s) is (are) all compliant with this
   specification or later.
</t>
<t>
   In Netscape&apos;s original proposal, no whitespace was permitted around
   the = that separates attribute-value pairs.  Therefore such
   whitespace should be used with caution in new implementations.
</t>
</section>
</section>
<!-- RFC original section: (10.2) -->
<section title="Caching and HTTP/1.0">
<t>
   Some caches, such as those conforming to HTTP/1.0, will inevitably
   cache the Set-Cookie header, because there was no mechanism to
   suppress caching of headers prior to HTTP/1.1.  This caching can lead
   to security problems.  Documents transmitted by an origin server
   along with Set-Cookie headers will usually either be uncachable, or
   will be &quot;pre-expired&quot;.  As long as caches obey instructions not to
   cache documents (following Expires: &lt;a date in the past&gt; or Pragma:
   no-cache (HTTP/1.0), or Cache-control: no-cache (HTTP/1.1))
   uncachable documents present no problem.  However, pre-expired
   documents may be stored in caches.  They require validation (a
   conditional GET) on each new request, but some cache operators loosen
   the rules for their caches, and sometimes serve expired documents
   without first validating them.  This combination of factors can lead
   to cookies meant for one user later being sent to another user.  The
   Set-Cookie header is stored in the cache, and, although the document
   is stale (expired), the cache returns the document in response to
   later requests, including cached headers.
</t>
</section>
</section>
<!-- RFC original section: (11.) -->
<section title="ACKNOWLEDGEMENTS">
<t>
   This document really represents the collective efforts of the
   following people, in addition to the authors: Roy Fielding, Marc
   Hedlund, Ted Hardie, Koen Holtman, Shel Kaphan, Rohit Khare.
</t>
</section>
<!-- RFC original section: (12.) -->
<section title="AUTHORS&apos; ADDRESSES (BOILERPLATE)">
<t>
This RFC contained boilerplate in this section which has been moved
to the RFC2223-compliant unnumbered section &quot;Author&apos;s Address.&quot;
</t>
</section>
</middle>
</rfc>
