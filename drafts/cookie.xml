<?xml version="1.0"?>
<?rfc toc="yes"?>
<?xml-stylesheet type="text/xml" href="rfc2629.xslt"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<rfc ipr="trust200902" docName="draft-abarth-cookie">
  <front>
    <title abbrev="HTTP State Management Mechanism">
      HTTP State Management Mechanism
    </title>
    <author initials="A." surname="Barth" fullname="Adam Barth">
      <organization abbrev="U.C. Berkeley">
        University of California, Berkeley
      </organization>
      <address>
        <email>abarth@eecs.berkeley.edu</email>
        <uri>http://www.adambarth.com/</uri>
      </address>
    </author>
    <date month="August" year="2009"/>
    <workgroup>http-state Working Group</workgroup>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t>This document defines the HTTP Cookie and Set-Cookie headers.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro" title="Introduction">
      <t>This document defines the HTTP Cookie and Set-Cookie header.</t>
    </section>
    <section title="Terminology">
      <t>The terms user agent, client, server, proxy, and origin server have
      the same meaning as in the HTTP/1.0 specification.</t>

      <t>Fully-qualified host name (FQHN) means either the fully-qualified
      domain name (FQDN) of a host (i.e., a completely specified domain name
      ending in a top-level domain such as .com or .uk), or the numeric
      Internet Protocol (IP) address of a host.
      <!-- The fully qualified domain name is preferred; use of numeric IP
      addresses is strongly discouraged.--></t>

      <t>The terms request-host and request-URI refer to the values the client
      would send to the server as, respectively, the host (but not port) and
      abs_path portions of the absoluteURI (http_URL) of the HTTP request line.
      Note that request-host must be a FQHN.  Hosts names can be specified
      either as an IP address or a FQHN string.  Sometimes we compare one host
      name with another.  Host A's name domain-matches host B's if
      <list style="symbols">
        <t>both host names are IP addresses and their host name strings match
        exactly; or</t>

        <t>both host names are FQDN strings and their host name strings match
        exactly; or</t>

        <t>A is a FQDN string and has the form NB, where N is a non-empty name
        string, B has the form .B, and B is a FQDN string.  (So, x.y.com
        domain-matches .y.com but not y.com.)</t>
      </list>
      </t>

      <t>Note that domain-match is not a commutative operation: a.b.c.com
      domain-matches .c.com, but not the reverse.</t>

      <t>Because it was used in Netscape's original implementation of state
      management, we will use the term cookie to refer to the state information
      that passes between an origin server and user agent, and that gets stored
      by the user agent.</t>
    </section>
    <section title="State and Sessions">
      <t>This document describes a way to create stateful sessions with HTTP
      requests and responses.  HTTP servers respond to each client request
      without relating that request to previous or subsequent requests; the
      technique allows clients and servers that wish to exchange state
      information to place HTTP requests and responses within a larger context,
      which we term a &quot;session&quot;.  This context might be used to
      create, for example, a &quot;shopping cart&quot;, in which user
      selections can be aggregated before purchase, or a magazine browsing
      system, in which a user's previous reading affects which offerings are
      presented.</t>

      <t>There are, of course, many different potential contexts and thus many
      different potential types of session.  The designers' paradigm for
      sessions created by the exchange of cookies has these key attributes:
      <list style="numbers">
        <t>Each session has a beginning and an end.</t>

        <t>Each session is relatively short-lived.</t>

        <t>Either the user agent or the origin server may terminate a
        session.</t>

        <t>The session is implicit in the exchange of state information.</t>
      </list>
      </t>
    </section>
    <section title="Outline">
      <t>We outline here a way for an origin server to send state information to
      the user agent, and for the user agent to return the state information to
      the origin server.</t>

      <section title="Syntax: General">
        <t>The two state management headers, Set-Cookie and Cookie, have common
        syntactic properties involving attribute-value pairs.  The following
        grammar uses the notation, and tokens DIGIT (decimal digits) and token
        (informally, a sequence of non-special, non-white space characters) from
        the HTTP/1.1 specification [RFC 2068] to describe their syntax.</t>

        <t>[TODO: Test this grammar.]</t>

        <figure>
          <artwork>
   av-pairs        =       av-pair *(&quot;;&quot; av-pair)
   av-pair         =       attr [&quot;=&quot; value]        ; optional value
   attr            =       token
   value           =       word
   word            =       token | quoted-string
          </artwork>
        </figure>

        <t>Attributes (names) (attr) are case-insensitive.  White space is
        permitted between tokens.  Note that while the above syntax description
        shows value as optional, most attrs require them.</t>

        <t>NOTE: The syntax above allows whitespace between the attribute and
        the = sign.</t>
      </section>
      <section title="Origin Server Role">
        <section title="General">
          <t>The origin server initiates a session, if it so desires.  (Note
          that &quot;session&quot; here does not refer to a persistent network
          connection but to a logical session created from HTTP requests and
          responses.  The presence or absence of a persistent connection should
          have no effect on the use of cookie-derived sessions).  To initiate a
          session, the origin server returns an extra response header to the
          client, Set-Cookie.  (The details follow later.)</t>

          <t>A user agent returns a Cookie request header (see below) to the
          origin server if it chooses to continue a session.  The origin server
          may ignore it or use it to determine the current state of the
          session.  It may send the client a Set-Cookie response header
          with the same or different information, or it may send no Set-Cookie
          header at all.<!-- The origin server effectively ends a session by
          sending the client a Set-Cookie header with Max-Age=0. --></t>

          <t>Servers may return a Set-Cookie response headers with any
          response.  User agents should send Cookie request headers, subject to
          other rules detailed below, with every request.</t>

          <t>An origin server may include multiple Set-Cookie headers in a
          response.  Note that an intervening gateway could fold multiple such
          headers into a single header.  [TODO: Investigate how UAs cope with
          such folded headers.]</t>
        </section>
        <section title="Set-Cookie Syntax">
          <t>The syntax for the Set-Cookie response header is</t>

          <t>[TODO: Valdiate this syntax.]</t>

          <figure>
            <artwork>
   set-cookie      =       &quot;Set-Cookie:&quot; cookies
   cookies         =       1#cookie
   cookie          =       NAME &quot;=&quot; VALUE *(&quot;;&quot; cookie-av)
   NAME            =       attr
   VALUE           =       value
   cookie-av       =       &quot;Comment&quot; &quot;=&quot; value
                   |       &quot;Domain&quot; &quot;=&quot; value
                   |       &quot;Max-Age&quot; &quot;=&quot; value
                           [TODO: Expires is clearly missing.]
                   |       &quot;Path&quot; &quot;=&quot; value
                   |       &quot;Secure&quot;
                   |       &quot;Version&quot; &quot;=&quot; 1*DIGIT
                           [TODO: Version is likely a fantasy.]
            </artwork>
          </figure>

          <t>Informally, the Set-Cookie response header comprises the token
          Set-Cookie:, followed by a comma-separated list of one or more
          cookies.  Each cookie begins with a NAME=VALUE pair, followed by zero
          or more semi-colon-separated attribute-value pairs.  The specific
          attributes and the semantics of their values follows.  The NAME=VALUE
          attribute-value pair must come first in each cookie.  The others, if
          present, can occur in any order.  If an attribute appears more than
          once in a cookie, the behavior is undefined.  [TODO: Test what happens
          when attributes are multiply defined.]
          <list>
            <t>NAME=VALUE
            <list>
              <t>Required.  The name of the state information
              (&quot;cookie&quot;) is NAME, and its value is VALUE.  NAMEs that
              begin with $ are reserved for other uses and must not be used by
              applications.  [TODO: I suspect the $ rule is a fantasy.]  The
              VALUE is opaque to the user agent and may be
              anything the origin server chooses to send, possibly in a
              server-selected printable ASCII encoding.   &quot;Opaque&quot;
              implies that the content is of interest and relevance only to the
              origin server.  The content may, in fact, be readable by anyone
              that examines the Set-Cookie header.</t>
            </list>
            </t>

            <t>Comment=comment
            <list>
              <t>Optional.  Because cookies can contain private information
              about a user, the Cookie attribute allows an origin server to
              document its intended use of a cookie.  The user can inspect the
              information to decide whether to initiate or continue a session
              with this cookie.  [TODO: Does this actually exist?]</t>
            </list>
            </t>

            <t>Domain=domain
            <list>
              <t>Optional.  The Domain attribute specifies the domain for which
              the cookie is valid.  An explicitly specified domain must always
              start with a dot.  [TODO: Test what happens without a dot.]</t>
            </list>
            </t>

            <t>Max-Age=delta-seconds
            <list>
              <t>Optional.  The Max-Age attribute defines the lifetime of the
              cookie, in seconds.  The delta-seconds value is a decimal
              non-negative integer.  [TODO: Test negative integers.]  After
              delta-seconds seconds elapse, the client should discard the
              cookie.  A value of zero means the cookie should be discarded
              immediately.</t>
            </list>
            </t>

            <t>Path=path
            <list>
              <t>Optional.  The Path attribute specifies the subset of URLs to
              which this cookie applies.</t>
            </list>
            </t>

            <t>Secure
            <list>
              <t>Optional.  The Secure attribute (with no value) directs the
              user agent to use only (unspecified) secure means to contact the
              origin server whenever it sends back this cookie.  [TODO: We
              should give better implementation advice than this.]</t>

              <t>The user agent (possibly under the user's control) may
              determine what level of security it considers appropriate for
              &quot;secure&quot; cookies.  The Secure attribute should be
              considered security advice from the server to the user agent,
              indicating that it is in the session's interest to protect
              the confidentiality of the cookie's value.</t>
            </list>
            </t>

            <t>Version=version
            <list>
              <t>Required [TODO: Unlikely].  The Version attribute, a decimal
              integer, identifies to which version of the state management
              specification the cookie conforms.  For this specification,
              Version=1 applies.  [TODO: Remove this attribute.]</t>
            </list>
            </t>
          </list>
          </t>
        </section>
        <section title="Controlling Caching">
          <t>[TODO: Should we go into this much detail here?  This seems
          redudant with the HTTP specs.]</t>

          <t>An origin server must be cognizant of the effect of possible
          caching of both the returned resource and the Set-Cookie header.
          Caching "public" documents is desirable.  For example, if the origin
          server wants to use a public document such as a "front door" page as
          a sentinel to indicate the beginning of a session for which a
          Set-Cookie response header must be generated, the page should be
          stored in caches "pre-expired" so that the origin server will see
          further requests.  "Private documents", for example those that
          contain information strictly private to a session, should not be
          cached in shared caches.</t>

          <t>If the cookie is intended for use by a single user, the Set-Cookie
          header should not be cached.  A Set-Cookie header that is intended to
          be shared by multiple users may be cached.</t>

          <t>The origin server should send the following additional HTTP/1.1
          response headers, depending on circumstances:  [TODO: Is this good
          advice?]
          <list style="symbols">
            <t>To suppress caching of the Set-Cookie header: Cache-control: no-
            cache="set-cookie".</t>
          </list>
          </t>

          <t>and one of the following:
          <list style="symbols">
            <t>To suppress caching of a private document in shared caches:
            Cache-Control: private.</t>

            <t>To allow caching of a document and require that it be validated
            before returning it to the client: Cache-Control:
            must-revalidate.</t>

            <t>To allow caching of a document, but to require that proxy caches
            (not user agent caches) validate it before returning it to the
            client: Cache-Control: proxy-revalidate.</t>

            <t>To allow caching of a document and request that it be validated
            before returning it to the client (by "pre-expiring" it):
            Cache-Control: max-age=0.  Not all caches will revalidate the
            document in every case.</t>
          </list>
          </t>

          <t>HTTP/1.1 servers must send Expires: old-date (where old-date is a
          date long in the past) on responses containing Set-Cookie response
          headers unless they know for certain (by out of band means) that
          there are no downsteam HTTP/1.0 proxies.  HTTP/1.1 servers may send
          other Cache-Control directives that permit caching by HTTP/1.1
          proxies in addition to the Expires: old-date directive; the
          Cache-Control directive will override the Expires: old-date for
          HTTP/1.1 proxies.</t>
        </section>
      </section>

      <section title="User Agent Role">
        <section title="Interpreting Set-Cookie">
          <t>The user agent keeps separate track of state information that
          arrives via Set-Cookie response headers from each origin server (as
          distinguished by name or IP address and port).  The user agent
          applies these defaults for optional attributes that are missing:
          <list style="hanging">
            <t hangText="Version">Defaults to "old cookie" behavior as
            originally specified by Netscape.  See the HISTORICAL section.
            [TODO: Unlikely.]</t>

            <t hangText="Domain">Defaults to the request-host.  (Note that
            there is no dot at the beginning of request-host.)  [TODO: This is
            important to test!]</t>

            <t hangText="Max-Age">The default behavior is to discard the cookie
            when the user agent exits.  [TODO: Interaction with Expires.]</t>

            <t hangText="Expires">The default behavior is to discard the cookie
            when the user agent exits.  [TODO: Interaction with Max-Age.]</t>

            <t hangText="Path">Defaults to the path of the request URL that
            generated the Set-Cookie response, up to, but not including, the
            right-most /.  [TODO: Test!  This seems wrong for paths that are
            just a single slash]</t>

            <t hangText="Secure">If absent, the user agent may send the cookie
            over an insecure channel.</t>
          </list>
          </t>
        </section>
        <section title="Rejecting Cookies">
          <t>To prevent possible security or privacy violations, a user agent
          must reject a cookie (shall not store its information) if any of the
          following is true:
          <list style="symbols">
            <t>The value of the Path attribute is not a prefix of the
            request-URI.  [TODO: This is a lie.]</t>

            <t>The value for the Domain attribute contains no embedded dots or
            does not start with a dot.</t>

            <t>The value for the request-host does not domain-match the Domain
            attribute.  [TODO: Test whether you can set a cookie for a
            subdomain of yourself.]</t>

            <t>The request-host is a FQDN (not IP address) and has the form HD,
            where D is the value of the Domain attribute, and H is a string
            that contains one or more dots.  [TODO: I don't think this is
            right.  foo.bar.baz.com can set a cookie for .baz.com]</t>

            <t>[TODO: Need to interact with public suffix list!]</t>
          </list>
          </t>

          <t>Examples:
          <list style="symbols">
            <t>A Set-Cookie from request-host y.x.foo.com for Domain=.foo.com
            would be rejected, because H is y.x and contains a dot.  [TODO: I
            don't think this is right.]</t>

            <t>A Set-Cookie from request-host x.foo.com for Domain=.foo.com
            would be accepted.</t>

            <t>A Set-Cookie with Domain=.com or Domain=.com., will be rejected,
            because there is no embedded dot.</t>

            <t>A Set-Cookie with Domain=foo.com will be rejected because the
            value for Domain does not begin with a dot.  [TODO: This seems
            unlikely, but test!]</t>

            <t>A Set-Cookie with Domain=.co.uk will be rejected because .co.uk
            is a public suffix.</t>
          </list>
          </t>
        </section>
        <section title="Cookie Management">
          <t>If a user agent receives a Set-Cookie response header whose NAME
          is the same as a pre-existing cookie, and whose Domain and Path
          attribute values exactly (string) match those of a pre-existing
          cookie, the new cookie supersedes the old.  However, if the
          Set-Cookie has a value for Max-Age of zero, the (old and new) cookie
          is discarded.  Otherwise cookies accumulate until they expire
          (resources permitting), at which time they are discarded.  [TODO: Do
          cookies really accumulate like this?  Also, need to talk about
          Expires]</t>

          <t>Because user agents have finite space in which to store cookies,
          they may also discard older cookies to make space for newer ones,
          using, for example, a least-recently-used algorithm, along with
          constraints on the maximum number of cookies that each origin server
          may set.  [TODO: Consider recommending a cookie eviction strategy
          that works in practice.]</t>

          <t>If a Set-Cookie response header includes a Comment attribute, the
          user agent should store that information in a human-readable form
          with the cookie and should display the comment text as part of a
          cookie inspection user interface.  [TODO: I think the Comment
          attribute is a fantasy.]</t>

          <t>User agents should allow the user to control cookie destruction.
          An infrequently-used cookie may function as a "preferences file" for
          network applications, and a user may wish to keep it even if it is
          the least-recently-used cookie.  One possible implementation would be
          an interface that allows the permanent storage of a cookie through a
          checkbox (or, conversely, its immediate destruction).  [TODO:
          Remove?]</t>

          <t>Privacy considerations dictate that the user have considerable
          control over cookie management.  The PRIVACY section contains more
          information.</t>
        </section>
        <section title="Sending Cookies to the Origin Server">
          <t>When it sends a request to an origin server, the user agent sends
          a Cookie request header to the origin server if it has cookies that
          are applicable to the request, based on
          <list style="symbols">
            <t>the request-host,</t>

            <t>the request-URI, and</t>

            <t>the cookie's age.</t>
          </list>
          </t>

          <t>The syntax for the header is:</t>

          <figure>
            <artwork type="abnf2616">
<![CDATA[
   cookie          =       "Cookie:" cookie-version
                           1*((";" | ",") cookie-value)
   cookie-value    =       NAME "=" VALUE [";" path] [";" domain]
   cookie-version  =       "$Version" "=" value
   NAME            =       attr
   VALUE           =       value
   path            =       "$Path" "=" value
   domain          =       "$Domain" "=" value
]]>
            </artwork>
          </figure>

          <t>[TODO: This syntax is entirely wrong.]</t>

          <t>The following rules apply to choosing applicable cookie-values
          from among all the cookies the user agent has.
          <list>
            <t>Domain Selection
            <list>
              <t>The origin server's fully-qualified host name must
              domain-match the Domain attribute of the cookie.</t>
            </list>
            </t>

            <t>Path Selection
            <list>
              <t>The Path attribute of the cookie must match a prefix of the
              request-URI.  [TODO: Need a more complex algorithm here involving
              the / character.]</t>
            </list>
            </t>

            <t>Max-Age Selection
            <list>
              <t>Cookies that have expired should have been discarded and thus
              are not forwarded to an origin server.</t>
            </list>
            </t>
          </list>
          </t>

          <t>If multiple cookies satisfy the criteria above, they are ordered
          in the Cookie header such that those with more specific Path
          attributes precede those with less specific.  Ordering with respect
          to other attributes (e.g., Domain) is unspecified.  [TODO: Figure out
          the correct ordering.]</t>

          <t>Note: For backward compatibility, the separator in the Cookie
          header is semi-colon (;) everywhere.  A server should also accept
          comma (,) as the separator between cookie-values for future
          compatibility.  [TODO: Test whether servers actually do this.]</t>
        </section>
        <section title="Sending Cookies in Unverifiable Transactions">
          <t>[TODO: This entire section seems like a fantasy.]</t>

          <t>[TODO: Consider explaining how third-party cookie blocking
          works.]</t>
        </section>
      </section>

      <section title="How an Origin Server Interprets the Cookie Header">
        <t>[TODO: This section appears to be nonsense.]</t>
      </section>
      <section title="Caching Proxy Role">
        <t>One reason for separating state information from both a URL and
        document content is to facilitate the scaling that caching permits.  To
        support cookies, a caching proxy must obey these rules already in the
        HTTP specification [TODO: If they're already in the HTTP specification,
        aren't they redundant here?]:
        <list style="symbols">
          <t>Honor requests from the cache, if possible, based on cache
          validity rules.</t>

          <t>Pass along a Cookie request header in any request that the proxy
          must make of another server.</t>

          <t>Return the response to the client.  Include any Set-Cookie
          response header.</t>

          <t>Cache the received response subject to the control of the usual
          headers, such as Expires, Cache-Control: no-cache, and Cache-Control:
          private.</t>

          <t>Cache the Set-Cookie subject to the control of the usual header,
          Cache-Control: no-cache="set-cookie".  (The Set-Cookie header should
          usually not be cached.)</t>
        </list>
        </t>

        <t>Proxies must not introduce Set-Cookie (Cookie) headers of their own
        in proxy responses (requests).</t>
      </section>
    </section>
    <section title="Examples">
      <section title="Example 1">
        <t>Most detail of request and response headers has been omitted.
        Assume the user agent has no stored cookies.</t>
        <list style="numbers"> 
          <t>User Agent -&gt; Server
            <figure>
              <artwork type='message/http: msgtype="request"'>
    POST /acme/login HTTP/1.1
    [form data]
              </artwork>
              <postamble>User identifies self via a form.</postamble>
            </figure>
          </t>

          <t>Server -&gt; User Agent
            <figure>
              <artwork type='message/http: msgtype="response"'>
    HTTP/1.1 200 OK
    Set-Cookie: Customer="WILE_E_COYOTE"; Version="1"; Path="/acme"
              </artwork>
              <postamble>Cookie reflects user's identity.  [TODO: This is
              insecure.]</postamble>
            </figure>
          </t>

          <t>User Agent -&gt; Server
            <figure>
              <artwork type='message/http: msgtype="request"'>
    POST /acme/pickitem HTTP/1.1
    Cookie: $Version="1"; Customer="WILE_E_COYOTE"; $Path="/acme"
    [form data]
              </artwork>
              <postamble>User selects an item for "shopping basket."</postamble>
            </figure>
          </t>

          <t>Server -&gt; User Agent
            <figure>
              <artwork type='message/http: msgtype="response"'>
    HTTP/1.1 200 OK
    Set-Cookie: Part_Number="Rocket_Launcher_0001"; Version="1"; Path="/acme"
              </artwork>
              <postamble>Shopping basket contains an item.</postamble>
            </figure>
          </t>

          <t>User Agent -&gt; Server
            <figure>
              <artwork type='message/http: msgtype="request"'>
    POST /acme/shipping HTTP/1.1
    Cookie: $Version="1";
            Customer="WILE_E_COYOTE"; $Path="/acme";
            Part_Number="Rocket_Launcher_0001"; $Path="/acme"
    [form data]
              </artwork>
              <postamble>User selects shipping method from form.</postamble>
            </figure>
          </t>

          <t>Server -&gt; User Agent
            <figure>
              <artwork type='message/http: msgtype="response"'>
    HTTP/1.1 200 OK
    Set-Cookie: Shipping="FedEx"; Version="1"; Path="/acme"
              </artwork>
              <postamble>New cookie reflects shipping method.</postamble>
            </figure>
          </t>

          <t>User Agent -&gt; Server
            <figure>
              <artwork type='message/http: msgtype="request"'>
    POST /acme/process HTTP/1.1
    Cookie: $Version="1";
            Customer="WILE_E_COYOTE"; $Path="/acme";
            Part_Number="Rocket_Launcher_0001"; $Path="/acme";
            Shipping="FedEx"; $Path="/acme"
    [form data]
              </artwork>
              <postamble>User chooses to process order.</postamble>
            </figure>
          </t>

          <t>Server -&gt; User Agent
            <figure>
              <artwork type='message/http: msgtype="response"'>
    HTTP/1.1 200 OK
              </artwork>
              <postamble>Transaction is complete.</postamble>
            </figure>
          </t>
        </list>
        </t>

        <t>[TODO: This example is really silly.  We shouldn't be recommending
        this at all.]

        <t>The user agent makes a series of requests on the origin server,
        after each of which it receives a new cookie.  All the cookies have the
        same Path attribute and (default) domain.  Because the request URLs all
        have /acme as a prefix, and that matches the Path attribute, each
        request contains all the cookies received so far.</t>
      </section>
      <section title="Example 2">
        <t>This example illustrates the effect of the Path attribute.  All
        detail of request and response headers has been omitted.  Assume the
        user agent has no stored cookies.</t>

        <t>Imagine the user agent has received, in response to earlier
        requests, the response headers
          <figure>
            <artwork type="example">
Set-Cookie: Part_Number="Rocket_Launcher_0001"; Version="1";
        Path="/acme"
            </artwork>
          </figure>
        and
          <figure>
            <artwork type="example">
Set-Cookie: Part_Number="Riding_Rocket_0023"; Version="1";
        Path="/acme/ammo"
            </artwork>
          </figure>
        </t>

        <t>A subsequent request by the user agent to the (same) server for URLs
        of the form /acme/ammo/...  would include the following request header:
          <figure>
            <artwork type="example">
Cookie: $Version="1";
        Part_Number="Riding_Rocket_0023"; $Path="/acme/ammo";
        Part_Number="Rocket_Launcher_0001"; $Path="/acme"
            </artwork>
          </figure>
        </t>

        <t>Note that the NAME=VALUE pair for the cookie with the more specific
        Path attribute, /acme/ammo, comes before the one with the less specific
        Path attribute, /acme.  Further note that the same cookie name appears
        more than once.</t>

        <t>A subsequent request by the user agent to the (same) server for a
        URL of the form /acme/parts/ would include the following request
        header:
          <figure>
            <artwork type="example">
Cookie: $Version="1"; Part_Number="Rocket_Launcher_0001"; $Path="/acme"
            </artwork>
          </figure>
        </t>

        <t>Here, the second cookie's Path attribute /acme/ammo is not a prefix
        of the request URL, /acme/parts/, so the cookie does not get forwarded
        to the server.</t>
      </section>
    </section>

  </middle>
  <back>
    <section title="Acknowledgements">
      <t>This document borrows heavily from RFC 2109.  [TODO: Figure out the
      proper way to credit the authors of RFC 2109.]</t>
    </section>
  </back>
</rfc>
