<?xml version="1.0"?>
<?rfc toc="yes"?>
<?xml-stylesheet type="text/xml" href="rfc2629.xslt"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<rfc ipr="trust200902" docName="draft-abarth-cookie">
  <front>
    <title abbrev="HTTP State Management Mechanism">
      HTTP State Management Mechanism
    </title>
    <author initials="A." surname="Barth" fullname="Adam Barth">
      <organization abbrev="U.C. Berkeley">
        University of California, Berkeley
      </organization>
      <address>
        <email>abarth@eecs.berkeley.edu</email>
        <uri>http://www.adambarth.com/</uri>
      </address>
    </author>
    <date month="August" year="2009"/>
    <workgroup>http-state Working Group</workgroup>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t>This document defines the HTTP Cookie and Set-Cookie headers.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro" title="Introduction">
      <t>This document defines the HTTP Cookie and Set-Cookie header.</t>
    </section>
    <section title="Terminology">
      <t>The terms user agent, client, server, proxy, and origin server have
      the same meaning as in the HTTP/1.0 specification.</t>

      <t>Fully-qualified host name (FQHN) means either the fully-qualified
      domain name (FQDN) of a host (i.e., a completely specified domain name
      ending in a top-level domain such as .com or .uk), or the numeric
      Internet Protocol (IP) address of a host.
      <!-- The fully qualified domain name is preferred; use of numeric IP
      addresses is strongly discouraged.--></t>

      <t>The terms request-host and request-URI refer to the values the client
      would send to the server as, respectively, the host (but not port) and
      abs_path portions of the absoluteURI (http_URL) of the HTTP request line.
      Note that request-host must be a FQHN.  Hosts names can be specified
      either as an IP address or a FQHN string.  Sometimes we compare one host
      name with another.  Host A's name domain-matches host B's if
      <list style="symbols">
        <t>both host names are IP addresses and their host name strings match
        exactly; or</t>

        <t>both host names are FQDN strings and their host name strings match
        exactly; or</t>

        <t>A is a FQDN string and has the form NB, where N is a non-empty name
        string, B has the form .B, and B is a FQDN string.  (So, x.y.com
        domain-matches .y.com but not y.com.)</t>
      </list>
      </t>

      <t>Note that domain-match is not a commutative operation: a.b.c.com
      domain-matches .c.com, but not the reverse.</t>

      <t>Because it was used in Netscape's original implementation of state
      management, we will use the term cookie to refer to the state information
      that passes between an origin server and user agent, and that gets stored
      by the user agent.</t>
    </section>
    <section title="State and Sessions">
      <t>This document describes a way to create stateful sessions with HTTP
      requests and responses.  HTTP servers respond to each client request
      without relating that request to previous or subsequent requests; the
      technique allows clients and servers that wish to exchange state
      information to place HTTP requests and responses within a larger context,
      which we term a &quot;session&quot;.  This context might be used to
      create, for example, a &quot;shopping cart&quot;, in which user
      selections can be aggregated before purchase, or a magazine browsing
      system, in which a user's previous reading affects which offerings are
      presented.</t>

      <t>There are, of course, many different potential contexts and thus many
      different potential types of session.  The designers' paradigm for
      sessions created by the exchange of cookies has these key attributes:
      <list style="numbers">
        <t>Each session has a beginning and an end.</t>

        <t>Each session is relatively short-lived.</t>

        <t>Either the user agent or the origin server may terminate a
        session.</t>

        <t>The session is implicit in the exchange of state information.</t>
      </list>
      </t>
    </section>
    <section title="Outline">
      <t>We outline here a way for an origin server to send state information to
      the user agent, and for the user agent to return the state information to
      the origin server.</t>

      <section title="Syntax: General">
        <t>The two state management headers, Set-Cookie and Cookie, have common
        syntactic properties involving attribute-value pairs.  The following
        grammar uses the notation, and tokens DIGIT (decimal digits) and token
        (informally, a sequence of non-special, non-white space characters) from
        the HTTP/1.1 specification [RFC 2068] to describe their syntax.</t>

        <t>[TODO: Test this grammar.]</t>

        <figure>
          <artwork>
   av-pairs        =       av-pair *(&quot;;&quot; av-pair)
   av-pair         =       attr [&quot;=&quot; value]        ; optional value
   attr            =       token
   value           =       word
   word            =       token | quoted-string
          </artwork>
        </figure>

        <t>Attributes (names) (attr) are case-insensitive.  White space is
        permitted between tokens.  Note that while the above syntax description
        shows value as optional, most attrs require them.</t>

        <t>NOTE: The syntax above allows whitespace between the attribute and
        the = sign.</t>
      </section>
      <section title="Origin Server Role">
        <section title="General">
          <t>The origin server initiates a session, if it so desires.  (Note
          that &quot;session&quot; here does not refer to a persistent network
          connection but to a logical session created from HTTP requests and
          responses.  The presence or absence of a persistent connection should
          have no effect on the use of cookie-derived sessions).  To initiate a
          session, the origin server returns an extra response header to the
          client, Set-Cookie.  (The details follow later.)</t>

          <t>A user agent returns a Cookie request header (see below) to the
          origin server if it chooses to continue a session.  The origin server
          may ignore it or use it to determine the current state of the
          session.  It may send the client a Set-Cookie response header
          with the same or different information, or it may send no Set-Cookie
          header at all.<!-- The origin server effectively ends a session by
          sending the client a Set-Cookie header with Max-Age=0. --></t>

          <t>Servers may return a Set-Cookie response headers with any
          response.  User agents should send Cookie request headers, subject to
          other rules detailed below, with every request.</t>

          <t>An origin server may include multiple Set-Cookie headers in a
          response.  Note that an intervening gateway could fold multiple such
          headers into a single header.  [TODO: Investigate how UAs cope with
          such folded headers.]</t>
        </section>
        <section title="Set-Cookie Syntax">
          <t>The syntax for the Set-Cookie response header is</t>

          <t>[TODO: Valdiate this syntax.]</t>

          <figure>
            <artwork>
   set-cookie      =       &quot;Set-Cookie:&quot; cookies
   cookies         =       1#cookie
   cookie          =       NAME &quot;=&quot; VALUE *(&quot;;&quot; cookie-av)
   NAME            =       attr
   VALUE           =       value
   cookie-av       =       &quot;Comment&quot; &quot;=&quot; value
                   |       &quot;Domain&quot; &quot;=&quot; value
                   |       &quot;Max-Age&quot; &quot;=&quot; value
                           [TODO: Expires is clearly missing.]
                   |       &quot;Path&quot; &quot;=&quot; value
                   |       &quot;Secure&quot;
                   |       &quot;Version&quot; &quot;=&quot; 1*DIGIT
                           [TODO: Version is likely a fantasy.]
            </artwork>
          </figure>

          <t>Informally, the Set-Cookie response header comprises the token
          Set-Cookie:, followed by a comma-separated list of one or more
          cookies.  Each cookie begins with a NAME=VALUE pair, followed by zero
          or more semi-colon-separated attribute-value pairs.  The specific
          attributes and the semantics of their values follows.  The NAME=VALUE
          attribute-value pair must come first in each cookie.  The others, if
          present, can occur in any order.  If an attribute appears more than
          once in a cookie, the behavior is undefined.  [TODO: Test what happens
          when attributes are multiply defined.]
          <list>
            <t>NAME=VALUE
            <list>
              <t>Required.  The name of the state information
              (&quot;cookie&quot;) is NAME, and its value is VALUE.  NAMEs that
              begin with $ are reserved for other uses and must not be used by
              applications.  [TODO: I suspect the $ rule is a fantasy.]  The
              VALUE is opaque to the user agent and may be
              anything the origin server chooses to send, possibly in a
              server-selected printable ASCII encoding.   &quot;Opaque&quot;
              implies that the content is of interest and relevance only to the
              origin server.  The content may, in fact, be readable by anyone
              that examines the Set-Cookie header.</t>
            </list>
            </t>

            <t>Comment=comment
            <list>
              <t>Optional.  Because cookies can contain private information
              about a user, the Cookie attribute allows an origin server to
              document its intended use of a cookie.  The user can inspect the
              information to decide whether to initiate or continue a session
              with this cookie.  [TODO: Does this actually exist?]</t>
            </list>
            </t>

            <t>Domain=domain
            <list>
              <t>Optional.  The Domain attribute specifies the domain for which
              the cookie is valid.  An explicitly specified domain must always
              start with a dot.  [TODO: Test what happens without a dot.]</t>
            </list>
            </t>

            <t>Max-Age=delta-seconds
            <list>
              <t>Optional.  The Max-Age attribute defines the lifetime of the
              cookie, in seconds.  The delta-seconds value is a decimal
              non-negative integer.  [TODO: Test negative integers.]  After
              delta-seconds seconds elapse, the client should discard the
              cookie.  A value of zero means the cookie should be discarded
              immediately.</t>
            </list>
            </t>

            <t>Path=path
            <list>
              <t>Optional.  The Path attribute specifies the subset of URLs to
              which this cookie applies.</t>
            </list>
            </t>

            <t>Secure
            <list>
              <t>Optional.  The Secure attribute (with no value) directs the
              user agent to use only (unspecified) secure means to contact the
              origin server whenever it sends back this cookie.  [TODO: We
              should give better implementation advice than this.]</t>

              <t>The user agent (possibly under the user's control) may
              determine what level of security it considers appropriate for
              &quot;secure&quot; cookies.  The Secure attribute should be
              considered security advice from the server to the user agent,
              indicating that it is in the session's interest to protect
              the confidentiality of the cookie's value.</t>
            </list>
            </t>

            <t>Version=version
            <list>
              <t>Required [TODO: Unlikely].  The Version attribute, a decimal
              integer, identifies to which version of the state management
              specification the cookie conforms.  For this specification,
              Version=1 applies.  [TODO: Remove this attribute.]</t>
            </list>
            </t>
          </list>
          </t>
        </section>
        <section title="Controlling Caching">
          <t>[TODO: Should we go into this much detail here?  This seems
          redudant with the HTTP specs.]</t>

          <t>An origin server must be cognizant of the effect of possible
          caching of both the returned resource and the Set-Cookie header.
          Caching "public" documents is desirable.  For example, if the origin
          server wants to use a public document such as a "front door" page as
          a sentinel to indicate the beginning of a session for which a
          Set-Cookie response header must be generated, the page should be
          stored in caches "pre-expired" so that the origin server will see
          further requests.  "Private documents", for example those that
          contain information strictly private to a session, should not be
          cached in shared caches.</t>

          <t>If the cookie is intended for use by a single user, the Set-Cookie
          header should not be cached.  A Set-Cookie header that is intended to
          be shared by multiple users may be cached.</t>

          <t>The origin server should send the following additional HTTP/1.1
          response headers, depending on circumstances:  [TODO: Is this good
          advice?]
          <list style="symbols">
            <t>To suppress caching of the Set-Cookie header: Cache-control: no-
            cache="set-cookie".</t>
          </list>
          </t>

          <t>and one of the following:
          <list style="symbols">
            <t>To suppress caching of a private document in shared caches:
            Cache-Control: private.</t>

            <t>To allow caching of a document and require that it be validated
            before returning it to the client: Cache-Control:
            must-revalidate.</t>

            <t>To allow caching of a document, but to require that proxy caches
            (not user agent caches) validate it before returning it to the
            client: Cache-Control: proxy-revalidate.</t>

            <t>To allow caching of a document and request that it be validated
            before returning it to the client (by "pre-expiring" it):
            Cache-Control: max-age=0.  Not all caches will revalidate the
            document in every case.</t>
          </list>
          </t>

          <t>HTTP/1.1 servers must send Expires: old-date (where old-date is a
          date long in the past) on responses containing Set-Cookie response
          headers unless they know for certain (by out of band means) that
          there are no downsteam HTTP/1.0 proxies.  HTTP/1.1 servers may send
          other Cache-Control directives that permit caching by HTTP/1.1
          proxies in addition to the Expires: old-date directive; the
          Cache-Control directive will override the Expires: old-date for
          HTTP/1.1 proxies.</t>
        </section>
      </section>

      <section title="User Agent Role">
        <section title="Interpreting Set-Cookie">
          <t>The user agent keeps separate track of state information that
          arrives via Set-Cookie response headers from each origin server (as
          distinguished by name or IP address and port).  The user agent
          applies these defaults for optional attributes that are missing:
          <list style="hanging">
            <t hangText="Version">Defaults to "old cookie" behavior as
            originally specified by Netscape.  See the HISTORICAL section.
            [TODO: Unlikely.]</t>

            <t hangText="Domain">Defaults to the request-host.  (Note that
            there is no dot at the beginning of request-host.)  [TODO: This is
            important to test!]</t>

            <t hangText="Max-Age">The default behavior is to discard the cookie
            when the user agent exits.  [TODO: Interaction with Expires.]</t>

            <t hangText="Expires">The default behavior is to discard the cookie
            when the user agent exits.  [TODO: Interaction with Max-Age.]</t>

            <t hangText="Path">Defaults to the path of the request URL that
            generated the Set-Cookie response, up to, but not including, the
            right-most /.  [TODO: Test!]</t>

            <t hangText="Secure">If absent, the user agent may send the cookie
            over an insecure channel.</t>
          </list>
          </t>
        </section>

      </section>
    </section>
  </middle>
  <back>
    <section title="Acknowledgements">
      <t>This document borrows heavily from RFC 2109.  [TODO: Figure out the
      proper way to credit the authors of RFC 2109.]</t>
    </section>
  </back>
</rfc>
